# FMI Buzz

Задачата "[Fizzbuzz](https://en.wikipedia.org/wiki/Fizz_buzz)" е класически проблем за интервюта, и както знаем, те винаги са силно практически и използваеми в реалния свят.

В случая, имате задача директно от шефа да имплементирате класически fizzbuzz, само че вместо да печатате нещата, ще ти вкарвате във вектор с определена дължина. Тоест, ще трябва да имплементирате следната функция:

``` rust
/// Вход: променлива `n`, която описва броя елементи, които ще генерираме в резултата.
///
/// За всяко число от 1 до `n` включително, искаме съответстващия елемент в резултата да е:
///
/// - String със съдържание "Fizz" ако числото се дели на 3, но не на 5
/// - String със съдържание "Buzz" ако числото се дели на 5, но не на 3
/// - String със съдържание "Fizzbuzz" ако числото се дели и на 3, и на 5
/// - Числото конвертирано до низ, във всички други случаи
///
/// Тоест, във `fizzbuzz(3)`, първия елемент ще бъде `String::from("1")`, втория
/// `String::from("2")`, последния `String::from("Fizz")`.
///
/// Ако `n` е 0, очакваме празен вектор за резултат.
///
pub fn fizzbuzz(n: usize) -> Vec<String> {
    todo!()
}
```

За да създадете низ от число, метода [`.to_string()`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string) ще ви свърши работа.

## Customization

Функцията ви е невероятно успешна, става и супер популярна в Reddit и HackerNews, всички се опитват да reverse-engineer-нат алгоритъма ви. Шефа е доволен, но клиентите искат промени! Как тъй само 3 и 5, искат всякакви числа да бъдат коефициенти.

Втората функция, която искаме да имплементирате, приема коефициентите като вход:

``` rust
/// Вход:
/// - променлива `n`, която описва броя елементи, които ще генерираме в резултата.
/// - променливи `k1` и `k2`, които са двата делителя, които ще използваме за заместване.
///
/// За всяко число от 1 до `n` включително, искаме съответстващия елемент в резултата да е:
///
/// - String със съдържание "Fizz" ако числото се дели на k1, но не на k2
/// - String със съдържание "Buzz" ако числото се дели на k2, но не на k1
/// - String със съдържание "Fizzbuzz" ако числото се дели и на k1, и на k2
/// - Числото конвертирано до низ, във всички други случаи
///
/// Ако `n` е 0, очакваме празен вектор за резултат.
/// Ако `k1` или `k2` са 0 или 1, очакваме функцията да panic-не с каквото съобщение изберете.
///
pub fn custom_buzz(n: usize, k1: u8, k2: u8) -> Vec<String> {
    todo!()
}
```

Тук може да си зададете въпроса, "хм, а какво става ако двете числа са едни и същи, или ако се делят едно на друго?" Отговора е, шефа не му пука, или иначе казано, ние няма да проверяваме функцията ви с други специални случаи, освен изрично описаните по-горе. Може да приемете, че подаваме `k1` и `k2` като взаимно прости числа, и също така няма да са толкова големи, че произведението им да надхвърли 255.

(В тоя ред на мисли, може да си спомните, че Rust ще ви направи проблем за аритметика между различни типове, така че вероятно ще се наложи да направите малко конвертиране между типове.)

## Even more customization

Клиентите искат още и още. Сега пък и низовете да били променяеми, защо само "Fizz", "Buzz" и "Fizzbuzz". Конкретно ФМИ имат нужда от "ПФОЗ", "ПФОЕС" и "ПФОЗИЕС" по някаква причина. Така че третата имплементация ще използва структура, на която даже клиентите ще могат да си сменят низовете в движение:

``` rust
/// Параметри:
/// - полета `k1` и `k2`, които са двата делителя, които ще използваме за заместване.
/// - поле `labels`, които са трите етикета, които съответстват на коефициентите
///
/// Ако `n` е 0, очакваме празен вектор за резултат.
/// Ако `k1` или `k2` са 0 или 1, очакваме функцията да panic-не с каквото съобщение изберете.
///
pub struct FizzBuzzer {
    pub k1: u8,
    pub k2: u8,
    pub labels: [String; 3],
}

impl FizzBuzzer {
    /// За всяко число от 1 до `n` включително, искаме съответстващия елемент в резултата да е:
    ///
    /// - Първия String от полето `labels` ако числото се дели на k1, но не на k2
    /// - Втория String от полето `labels` ако числото се дели на k2, но не на k1
    /// - Третия String от полето `labels` ако числото се дели и на k1, и на k2
    /// - Числото конвертирано до низ, във всички други случаи
    ///
    pub fn get(&self, n: usize) -> Vec<String> {
        todo!()
    }

    /// Параметъра `index` указва кой етикет от полето `labels` променяме, от 0 до 2. Ако подадения
    /// `index` е извън тези рамки, очакваме функцията да panic-не.
    ///
    /// Стойността `value` е низа, който ще сложим на този индекс в полето `labels`.
    ///
    pub fn change_label(&mut self, index: usize, value: &String) {
        todo!()
    }
}
```

И тук не ни пука дали `k1` и `k2` се делят взаимно, както при горната функция.
