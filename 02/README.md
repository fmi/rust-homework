# Polynomial

С тази задача, ще ви накараме да упражните уменията си с итератори, цикли, вектори и аритметични операции.

За целта трябва да дефинирате структура `Polynomial`, която да има следния публичен интерфейс

```rust
/// Структура която представя полином от `n`та степен на една променлива
///
/// Пример за такъв полином e `x^2 + 2*x + 1`.
#[derive(Debug, Clone)]
pub struct Polynomial {
    // ...
}

impl Polynomial {
    /// Проверява дали една точка удовлетворява полинома
    ///
    /// Ако имаме точка (x, y) тогава тя удовлетворява полинома P(X), ако `|P(x) - y| < 1e-10`.
    fn has(&self, point: &(f64, f64)) -> bool {
        // ...
    }

    /// Намира полином, който минава през подадените точки, по метода на Лагранж, описан
    /// по-долу.
    ///
    /// Примерен полином, който минава през точките (-1.0, 0.0), (0.0, 1.0), (1.0, 4.0)
    /// е `x^2 + 2*x + 1`.
    ///
    /// Ако две точки имат равни X координати, върнете `None`.
    ///
    /// Няма да тестваме с NAN или INFINITY, така че не е нужно да проверявате специфично за тези
    /// стойности. Можете да го направите, разбира се, ако решите.
    ///
    fn interpolate(points: Vec<(f64, f64)>) -> Option<Self> {
        // ...
    }
}

impl From<Vec<f64>> for Polynomial {
    /// Създава нов полином от подадените коефициенти
    ///
    /// Редът на коефициентите е от най-високата степен на променливата към най-малката.
    ///
    /// Ако е подаден празен вектор се създава полином отговарящ на константата `0.0`. Ако на
    /// най-високите степени на полинома има нули, премахнете ги. (Това е причината аргумента
    /// `coefs` да се предава като `mut coefs`. Тоест:
    ///
    /// - Polynomial::from(vec![]) == Polynomial::from(vec![0.0]);
    /// - Polynomial::from(vec![0.0, 1.0]) == Polynomial::from(vec![1.0]);
    ///
    /// Полином който отговаря на Polynomial::from(vec![1.0, 2.0, 0.0, 3.0])
    /// е `x^3 + 2.0*x^2 + 3.0`.
    ///
    fn from(mut coefs: Vec<f64>) -> Self {
        // ...
    }
}

/// Създава полином отговарящ на константата `0.0`
impl Default for Polynomial { /* ... */ }

/// Проверява дали два полинома са равни.
///
/// Сравнява коефициентите пред всяка степен от двата полинома. Приемаме, че два коефициента
/// са равни ако разликата между тях е по-малка от 1e-10, т.е. |Ai - Bi| < 1e-10.
///
/// Ако полиномите имат водещи нули те трябва да се игнорират. Например следните два полинома
/// са равни:
///
/// -                     x^3 + 2.0*x^2 + 3.0
/// - 0.0*x^5 + 0.0*x^4 + x^3 + 2.0*x^2 + 3.0
///
impl PartialEq for Polynomial {
    fn eq(&self, rhs: &Self) -> bool {
        // ...
    }
}

/// Умножава полином с f64 -- всички коефициенти биват умножени с дясната страна.
///
/// За този метод, и по-долните, вижте внимателно сигнатурата на метода и мислете по какъв
/// начин се предава `self` и как може да използвате това. Може да си опростите живота, ако
/// мислите за ownership-а на стойността.
///
impl Mul<f64> for Polynomial {
    type Output = Polynomial;
    fn mul(self, rhs: f64) -> Self::Output;
}

/// Дели полином с f64 -- всички коефициенти биват разделени на дясната страна.
impl Div<f64> for Polynomial {
    type Output = Polynomial;
    fn div(self, rhs: f64) -> Self::Output;
}

/// Умножава полином с полином -- всички компоненти на полинома биват умножени с всички
/// компоненти на десния полином.
///
/// Пример:
///
/// Polynomial::from(vec![1.0, 2.0]) * Polynomial::from(vec![2.0, 1.0])
/// // => Polynomial::from(vec![2.0, 5.0, 2.0])
///
impl Mul for Polynomial {
    type Output = Polynomial;
    fn mul(self, rhs: Polynomial) -> Self::Output;
}

/// Събира полином с полином -- коефициентите на едни и същи степени се събират. Ако това
/// докара най-високите степени до 0, не забравяйте да премахнете нулите, също както `from`
/// метода по-горе.
///
impl Add for Polynomial {
    type Output = Polynomial;
    fn add(self, rhs: Polynomial) -> Self::Output;
}
```

За интерполацията може да използвате метода на Лагранж: Интерполационният полином на Лагранж L(x) за дадено множество от точки

![Точки](https://wikimedia.org/api/rest_v1/media/math/render/svg/5e4f064b4751bb32d87cc829aca1b2b2f38d4a6d)

се намира по формулата:

![Интерполационен полином](https://wikimedia.org/api/rest_v1/media/math/render/svg/d07f3378ff7718c345e5d3d4a57d3053190226a0)

където

![Базов полином](https://wikimedia.org/api/rest_v1/media/math/render/svg/6e2c3a2ab16a8723c0446de6a30da839198fb04b)

![Ограничения](https://wikimedia.org/api/rest_v1/media/math/render/svg/4fbacffa9af137cb08ee9eb1ce4ee402a61b48ac)

### Материали

* [https://en.wikipedia.org/wiki/Polynomial]()
* [https://en.wikipedia.org/wiki/Lagrange_polynomial]()

Внимавайте всички типове и методи, които ни трябват, да бъдат маркирани като `pub`, за да могат тестовете ни да ги викат.

Прочетете и общия [guide за писане на домашни](https://fmi.rust-lang.bg/tasks/guide).
