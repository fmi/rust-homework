# Итериране на матрици

За предното домашно, вместо `.by_row()` и `.by_col()` да връщаха вектори, щеше да е доста по-гъвкаво да са итератори -- кеф ти да ги collect-неш във вектор, кеф ти да ги итерираш по reference. Но решихме, че ще е ненужна допълнителна работа и може да остане за предизвикателство.

Ето го и него:

``` rust
#[derive(Debug)]
pub struct Matrix<T> {
    // каквото ви трябва
}

impl<T: Clone> Matrix<T> {
    /// Конструира матрица с брой редове `rows` и брой колони `cols`. Данните би трябвало да бъдат
    /// поне `rows * cols`, но няма да тестваме с масиви, които са твърде малки или твърде големи.
    /// Ако искате да panic-нете при невалиден вход, ваш избор.
    ///
    /// Данните ще са наредени в плосък масив по редове. Очаква се да държите ownership над тях,
    /// така че си ги клонирайте и си ги наредете както ви е удобно.
    ///
    pub fn new(rows: usize, cols: usize, data: &[T]) -> Self {
        todo!()
    }

    pub fn by_row(&self) -> RowIter<T> {
        todo!()
    }

    pub fn by_col(&self) -> ColIter<T> {
        todo!()
    }
}

pub struct RowIter<T> {
    // каквото ви трябва
}

pub struct ColIter<T> {
    // каквото ви трябва
}
```

Очакваме да имплементирате `Iterator` trait-а и за `RowIter`, и за `ColIter`, като ще трябва да итерирате по reference. Ще трябва да промените малко типовете по-горе за да сложите нужните lifetimes. Не би трябвало да е особено изненадващо -- имаме примери за имплементиране на итератори из видеата.

Ето един примерен test, който би трябвало да се компилира и да работи:

``` rust
#[test]
fn test_iteration_0() {
    let data = [1, 2,
                3, 4];
    let matrix = Matrix::new(2, 2, &data);

    assert_eq!(matrix.by_row().collect::<Vec<_>>(), vec![&1, &2, &3, &4]);
    assert_eq!(matrix.by_col().collect::<Vec<_>>(), vec![&1, &3, &2, &4]);
}
```
