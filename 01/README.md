# Digital root

Дигиталния корен на едно число може да получим като съберем цифрите му, после съберем цифрите на резултата му и така нататък, докато получим една-единствена цифра. Примерно, за числото `345`:

```
3 + 4 + 5 = 12
1 + 2 = 3
```

И така, дигиталния корен на `345` е цифрата `3`. Или поне в десетична бройна система. В шестнадесетична, дигиталния корен би бил `c`. Друг пример в шестнадесетична система, `7b`:

```
7 + b = 12 (7 + 11 = 18 в десетични сметки)
1 + 2 = 3
```

Корена на `7b` е `3`, поне в тази бройна система.

Искаме от вас да имплементирате няколко функции, които да изчислят дигиталния корен в конкретни бройни системи. Нужно е да се справяте само с неотрицателни числа. Входа е низ, който бива интерпретиран като число в съответната бройна система. Изхода е число (опаковано в `Option`), което би трябвало да е една "цифра" в тази бройна система.

Ако подадем низ, който е невалиден за дадената бройна система, очакваме функциите да върнат `None`. Забележете, че функциите, които ще използвате в стандартната библиотека вероятно ще връщат или `Option`, или `Result` в ситуации, в които входа е невалиден. Типа `Result` може да се превърне в `Option` чрез метода `.ok()`.

Няма да подаваме низове, чиято сума на цифрите да надхвърли капацитета на `u32`, така че не мислете твърде дълбоко за тази възможност.

За низовете в шестнадесетична бройна система, ще подаваме само малки букви, тоест "7b" но не "7B".

Свободни сте да имплементирате каквито искате помощни функции, ако ви трябват. Публичните функции трябва да имат този интерфейс:

```rust
/// Десетична бройна система: 0-9
pub fn decimal(input: &str) -> Option<u32> {
    unimplemented!()
}

/// Шестнадесетична бройна система: 0-9, последвано от a-f
pub fn hex(input: &str) -> Option<u32> {
    unimplemented!()
}

/// Осмична бройна система: 0-7
pub fn octal(input: &str) -> Option<u32> {
    unimplemented!()
}

/// Двоична бройна система: 0-1
pub fn binary(input: &str) -> Option<u32> {
    unimplemented!()
}
```

Внимавайте всички типове и методи, които ни трябват, да бъдат маркирани като `pub`, за да могат тестовете ни да ги викат (както сме сложили в шаблона). Бъдете *сигурни*, че кода ви се компилира заедно с [базовия тест](https://github.com/fmi/rust-homework/blob/e11d034bd2deadbc86c8a6ac56e941b8f17c22d1/01/test_basic.rs), но не разчитайте, че базовия тест ще ви хване бъговете.

Разгледайте документацията на [char](https://doc.rust-lang.org/std/primitive.char.html) и на [u32](https://doc.rust-lang.org/std/primitive.u32.html) и вероятно ще намерите полезни функции и методи които да ви улеснят живота.

Прочетете и общия [guide за писане на домашни](https://fmi.rust-lang.bg/tasks/guide). И си пуснете подходящ [soundtrack](https://www.youtube.com/watch?v=spsY11KIFDM) докато пишете.
